use std::env;
use std::fs::{File, rename};
use std::io::{self, BufReader, copy, Cursor, Write, prelude::*};
use std::cmp::min;
use std::path::Path;
use std::{thread, time::Duration};
use rusqlite::{Connection, Result, MappedRows};
use tempfile::Builder;
use reqwest::{Client,StatusCode};
use indicatif::{ProgressBar, ProgressStyle};
use futures_util::StreamExt;
use version_compare::{Cmp, Version};
const VERSION:&str = "Eoka 0.0.0";


// fn open_file(filename: impl AsRef<Path>) -> Vec<String> {
//     let file = File::open(filename).expect("no such file");
//     let buf = BufReader::new(file);
//     buf.lines()
//         .map(|l| l.expect("Could not parse line"))
//         .collect()
// }

#[derive(Debug,Default)]
struct Package {
    name: String,
    lversion: String,
    rversion: String,
    dependencies: Option<String>,
}
fn sql_get(database:&str, value:&str) -> Result<Vec<String>> {//Mirar para devolver rows enteras
    let localdb = Connection::open(database)?;
    let mut stmt = localdb.prepare("SELECT * FROM data WHERE name = :id")?;
    let rows = stmt.query_map(&[(":id", value)], |row| row.get(1))?;
    let mut names = Vec::new();
    for name_result in rows {
        names.push(name_result?);
    }
    Ok(names)
}
fn pkg_list(db:&str)-> Vec<Package>{
    let localdb = Connection::open(db).expect("Unable to open DB");
    let mut stmt = localdb.prepare("SELECT name, lversion, rversion, dependencies FROM packages").unwrap();
    let rows = stmt.query_map([], |row| {
        Ok(Package {
            name: row.get(0).unwrap(),
            lversion: row.get(1).unwrap(),
            rversion: row.get(2).unwrap(),
            dependencies: row.get(3).unwrap(),
        })
    }).expect("Unable to process all the lines");
    let mut array = Vec::new();
    for row in rows {
        array.push(row.unwrap());
    }
    return array
}
fn pkg_add(id:&String, rversion:&String, dependencies:Option<String>){
    let localdb = Connection::open("local.db").expect("Unable to open DB");
    localdb.execute("INSERT INTO packages VALUES(?1, '', ?2, ?3)", (id, rversion, dependencies),).expect("Failed to add package to the database");
}
fn pkg_update(value:&String, id:&String, opt:bool){
    let localdb = Connection::open("local.db").expect("Unable to open DB");
    if opt {
        localdb.execute("UPDATE packages SET rversion = ?1 WHERE name = ?2", (value, id),).expect("Failed to update the value");
    }else{
        localdb.execute("UPDATE packages SET lversion = ?1 WHERE name = ?2", (value, id),).expect("Failed to update the value");
    }
}
fn sql_pkg(id:&str,db:&str)-> Package{
    let localdb = Connection::open(db).expect("Unable to open DB");
    let mut stmt = localdb.prepare("SELECT name, lversion, rversion, dependencies FROM packages WHERE name = :id").unwrap();
    let rows = stmt.query_map(&[(":id", id)], |row| {
        Ok(Package {
            name: row.get(0).unwrap(),
            lversion: row.get(1).unwrap(),
            rversion: row.get(2).unwrap(),
            dependencies: row.get(3).unwrap(),
        })
    }).expect("Unable to process all the lines");
    let mut value = Package::default();
    for row in rows {
        value = row.unwrap();
    }
    return value
}
fn compare_versions(lv:String,rv:String,verbose:bool) -> bool{
    let local = Version::from(&lv).expect("Error on version format");
    let remote = Version::from(&rv).expect("Error on version format");
    if !verbose{
        println!("{:?}", local);
        println!("{:?}", remote);
    }
    match local.compare(remote){
        Cmp::Lt => return true,
        _ => return false,
    }
}
async fn download_file(url:&str,verbose:bool,filename:Option<&str>)->String{//Checkear donde quiero guardar las ddbb -> /etc/eoka.d/remote.db
    // let mut response;
    // let mut fname;
    // for repo in open_file("repos.txt"){
    let target = "http://".to_owned() + url;
    fname = url.split("/").last().expect("Invalid URL").to_owned();
    if verbose {
        println!("Downloading {}", target);
    }
    let client = reqwest::Client::new();
    let mut response = client.get(&target).send().await;
    // if response.as_ref().expect("Unable to get data").status() == StatusCode::OK{
    //     break;
    // }
    // }
    let fs = response.content_length().expect("Error fetching file size");
    let pb = ProgressBar::new(fs);
    pb.set_style(ProgressStyle::default_bar()
        .template("{msg}\n{spinner:.red} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec}, {eta})").expect("Error theming the progress bar"));
    pb.set_message(format!("Downloading {}", fname.split(".").nth(0).unwrap()));
    let mut file = File::create(&fname).expect("Error while creating file");
    let mut downloaded: u64 = 0;
    let mut stream = response.bytes_stream();
    while let Some(item) = stream.next().await {
        let chunk = item.expect("Error while downloading file");
        file.write_all(&chunk).expect("Error while writing to file");
        let new = min(downloaded + (chunk.len() as u64), fs);
        downloaded = new;
        pb.set_position(new);
    }
    pb.finish_with_message(format!("Downloaded {}", fname));
    return fname;
}
async fn update_db(verbose:bool){
    let local = sql_get("local.db","version").unwrap();
    let remote = download_file("mirror.confugiradores.es/eoka.db",verbose,Some("remote.db")).await;
    let remote = sql_get(&remote,"version").unwrap();
    let res = compare_versions(local[0].to_owned(), remote[0].to_owned(), verbose);
    println!("Updating local database");
    if res {
        let packages = pkg_list("eoka.db");
        let pb = ProgressBar::new(packages.len().try_into().unwrap());
        pb.set_style(ProgressStyle::default_bar()
            .template("{spinner:.red} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {pos}/{len} ({msg}, {eta})").expect("Error theming the progress bar"));
        pb.set_message("Updating packages");
        let mut up = 0;
        let mut add = 0;
        for package in packages{
            let lversion = sql_pkg(&package.name,"local.db");
            if (&lversion.rversion).is_empty() {
                add+=1;
                pkg_add(&package.name, &package.rversion, package.dependencies);
            }
            if compare_versions(package.lversion,lversion.lversion,verbose){
                up+=1;
                pkg_update(&package.name, &package.rversion,true);
            }
            pb.set_message(package.name);
            pb.inc(1);
        }
        pb.finish_with_message("Finished");
        println!("Database has been updated, {} new packages have been added, {} updates available.", add, up);
    }
    else{
        println!("Database up to date.");
    }
}
async fn install_pkg(pkgname:String,verbose:bool){
    let pkgname = sql_pkg(&pkgname,"local.db");
    download_file(&("mirror.confugiradores.es/".to_owned() + &pkgname.name + "/" + &pkgname.name + "-" + &pkgname.rversion + ".tgz"), verbose, None).await;
}
#[tokio::main]
async fn main() {
    env::set_var("RUST_BACKTRACE", "1");
    let mut verbose:bool = true;//Invertir 
    let args = env::args().skip(1);
    if verbose{//DELETE
        println!("{:?}",args);
    }
    println!("{}",env::args().len());
    let args:Vec<String> = env::args().collect();
    // let mut skip:bool = false;
    for x in 1..args.len(){
    // for arg in args{//Cambiar la estructura para poder saltar en caso de que fuese necesario
        if args[x].chars().nth(0).unwrap() == '-'{//Cambiar para que se contemple --
            match args[x].chars().nth(1).unwrap(){
                'V' => println!("{}",VERSION),
                'v' => verbose = true,
                'L' => {//Installed, upgradable, available
                    let opt = &args[x+1];
                    match opt.as_str(){
                        "installed" => {

                        },
                        "upgradable" => {

                        },
                        "available" => {

                        },
                        _ => {
                            let package = sql_pkg("","");
                            if &package.lversion != "" {
                                println!("----- {} (Installed)\n Version: {}", &opt, &package.lversion);
                            }
                            println!("Last version: {}", &package.rversion);
                            for dep in &package.dependencies{
                                println!("- {} ", dep);
                            }
                        },
                    }
                },
                'S' => {
                    update_db(verbose).await;
                },
                'i' => {
                    println!("Installing package {}",&args[x+1]);
                    install_pkg(args.get(x+1).unwrap().to_string(), verbose).await;
                },
                'r' => println!("Removing package"),
                'p' => println!("Purging package"),
                'u' => println!("Updating package"),
                'U' => println!("Upgrading all packages"),
                'l' => println!("Eoka options\n-V: Get Eoka version\n-v: Enable verbosity\n-l: List all available commands"),
                _ => println!("Unknown argument, use eoka -l to list all available commands"),
            }
        }else{
            match args[x].as_str(){
                "sync" => println!("Syncing database"),
                "install" => println!("Installing package"),
                "remove" => println!("Removing package"),
                "purge" => println!("Purging package"),
                "update" => println!("Updating package"),
                "upgrade" => println!("Upgrading all packages"),
                _ => println!("No luck"),
            }
        }
    }
    if verbose{
        println!("Verbose enabled");
    }
    // let result = compare_versions(verbose).await;
    // if result {
    //     println!("WAWAWAWA");
    // }
    // open_file("../repos.txt");
}
